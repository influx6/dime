import (
	"context"
	"testing"
	"time"

	"github.com/influx6/dime/services"
	"github.com/influx6/faux/tests"
)

func Test{{sel "Name"}}Collect(t *testing.T) {
	t.Logf("When all data is received before 3 second")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 100*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		outgoing := services.{{sel "Name"}}Collect(ctx, 10*time.Millisecond, incoming)

		go func() {
			defer close(incoming)

			for i := 20; i > 0; i-- {
				select {
				case <-ctx.Done():
					return
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				case incoming <- {{sel "Type"}}{"day":"monday"}:
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				case incoming <- {{sel "Type"}}{"day":"monday"}:
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				case incoming <- {{sel "Type"}}{"day":"monday"}:
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				case incoming <- {{sel "Type"}}('b'):
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				case incoming <- {{sel "Type"}}('b'):
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				case incoming <- {{sel "Type"}}("bashful"):
				{{ end }}
				{{ if eq (sel "Type") "uint" }}
				case incoming <- 1:
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				case incoming <- 1:
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				case incoming <- 1:
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				case incoming <- 1:
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				case incoming <- 1.0:
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				case incoming <- 1.0:
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				case incoming <- 1.0:
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				case incoming <- 1.0:
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				case incoming <- (i%2 == 0):
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				case incoming <- errors.New(fmt.Sprintf("%q","monday")):
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				case incoming <- fmt.Sprintf("%q","monday"):
				{{ end }}
					continue
				}
			}
		}()

		received, ok := <-outgoing
		if !ok {
			tests.Failed("Should have fully received all items before 100ms")
		}
		tests.Passed("Should have fully received all items before 100ms")

		if received == nil {
			tests.Failed("Should have received 20 items but got %d", len(received))
		}
		tests.Passed("Should have received 20 items.")
	}

	t.Logf("When all data is not received after 3 second")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 100*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		outgoing := services.{{sel "Name"}}Collect(ctx, 10*time.Millisecond, incoming)

		go func() {
			for i := 20; i > 0; i-- {
				select {
				case <-ctx.Done():
					return
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				case incoming <- {{sel "Type"}}{"day":"monday"}:
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				case incoming <- {{sel "Type"}}{"day":"monday"}:
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				case incoming <- {{sel "Type"}}{"day":"monday"}:
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				case incoming <- {{sel "Type"}}('b'):
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				case incoming <- {{sel "Type"}}('b'):
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				case incoming <- {{sel "Type"}}("bashful"):
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				case incoming <- 1:
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				case incoming <- 1:
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				case incoming <- 1:
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				case incoming <- 1:
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				case incoming <- 1.0:
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				case incoming <- 1.0:
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				case incoming <- 1.0:
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				case incoming <- 1.0:
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				case incoming <- (i%2 == 0):
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				case incoming <- errors.New(fmt.Sprintf("%q","monday")):
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				case incoming <- fmt.Sprintf("%q","monday"):
				{{ end }}
					time.Sleep(50 * time.Millisecond)
					continue
				}
			}
		}()

		_, ok := <-outgoing
		if ok {
			tests.Failed("Should have not received any items after 100ms")
		}
		tests.Passed("Should have not received any items after 100ms")
	}

	t.Logf("When sending channel is not closed we should not get collected items")
	{
		ctx, cancl := context.WithTimeout(context.Background(), 10*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		outgoing := services.{{sel "Name"}}Collect(context.Background(), 10*time.Millisecond, incoming)

		go func() {
			for i := 3; i > 0; i-- {
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming <- {{sel "Type"}}('b')
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming <- fmt.Sprintf("%q","monday")
				{{ end }}
			}
		}()

		select {
		case <-ctx.Done():
			tests.Passed("Should not have received items after context closed")
		case <-outgoing:
			tests.Failed("Should not have received items after context closed")
		}
	}
}

func Test{{sel "Name"}}PartialCollect(t *testing.T) {
	t.Logf("When all data is received before 3 second")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 100*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		outgoing := services.{{sel "Name"}}PartialCollect(ctx, 10*time.Millisecond, incoming)

		go func() {
			for i := 20; i > 0; i-- {
				select {
				case <-ctx.Done():
					return
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				case incoming <- {{sel "Type"}}{"day":"monday"}:
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				case incoming <- {{sel "Type"}}{"day":"monday"}:
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				case incoming <- {{sel "Type"}}{"day":"monday"}:
				{{ end }}
				{{ if  eq (sel "Type") "rune" }}
				case incoming <- {{sel "Type"}}('b'):
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				case incoming <- {{sel "Type"}}('b'):
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				case incoming <- {{sel "Type"}}("bashful"):
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				case incoming <- 1:
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				case incoming <- 1:
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				case incoming <- 1:
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				case incoming <- 1:
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				case incoming <- 1.0:
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				case incoming <- 1.0:
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				case incoming <- 1.0:
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				case incoming <- 1.0:
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				case incoming <- (i%2 == 0):
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				case incoming <- errors.New(fmt.Sprintf("%q","monday")):
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				case incoming <- fmt.Sprintf("%q","monday"):
				{{ end }}
					continue
				}
			}
		}()

		received, ok := <-outgoing
		if !ok {
			tests.Failed("Should have fully received all items before 100ms")
		}
		tests.Passed("Should have fully received all items before 100ms")

		if received == nil {
			tests.Failed("Should have received 20 items but got %d", len(received))
		}
		tests.Passed("Should have received 20 items.")
	}

	t.Logf("When all data is received after 3 second")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 100*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		outgoing := services.{{sel "Name"}}PartialCollect(ctx, 10*time.Millisecond, incoming)

		go func() {
			for i := 20; i > 0; i-- {
				select {
				case <-ctx.Done():
					return
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				case incoming <- {{sel "Type"}}{"day":"monday"}:
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				case incoming <- {{sel "Type"}}{"day":"monday"}:
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				case incoming <- {{sel "Type"}}{"day":"monday"}:
				{{ end }}
				{{ if  eq (sel "Type") "rune" }}
				case incoming <- {{sel "Type"}}('b'):
				{{ end }}
				{{ if  eq (sel "Type") "rune" }}
				case incoming <- {{sel "Type"}}('b'):
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				case incoming <- {{sel "Type"}}('b'):
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				case incoming <- {{sel "Type"}}("bashful"):
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				case incoming <- 1:
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				case incoming <- 1:
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				case incoming <- 1:
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				case incoming <- 1:
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				case incoming <- 1.0:
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				case incoming <- 1.0:
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				case incoming <- 1.0:
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				case incoming <- 1.0:
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				case incoming <- (i%2 == 0):
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				case incoming <- 2:
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				case incoming <- errors.New(fmt.Sprintf("%q","monday")):
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				case incoming <- fmt.Sprintf("%q","monday"):
				{{ end }}
					time.Sleep(60 * time.Millisecond)
					continue
				}
			}
		}()

		received, ok := <-outgoing
		if !ok {
			tests.Failed("Should have fully received only 2 items after 100ms")
		}
		tests.Passed("Should have fully received only 2 items after 100ms")

		if received == nil {
			tests.Failed("Should have received 2 items but got %d", len(received))
		}
		tests.Passed("Should have received %d items.", len(received))
	}

	t.Logf("When sending channel is closed we should still get collected items")
	{
		ctx, cancl := context.WithTimeout(context.Background(), 10*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		outgoing := services.{{sel "Name"}}PartialCollect(context.Background(), 10*time.Millisecond, incoming)

		go func() {
			defer close(incoming)

			for i := 3; i > 0; i-- {
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming <- fmt.Sprintf("%q","monday")
				{{ end }}
			}
		}()

		select {
		case <-ctx.Done():
			tests.Failed("Should have received items before context closed")
		case received, ok := <-outgoing:
			if !ok {
				tests.Failed("Should have fully received only 2 items after 100ms")
			}
			tests.Passed("Should have fully received only 2 items after 100ms")

			if received == nil {
				tests.Failed("Should have received 3 items but got %d", len(received))
			}
			tests.Passed("Should have received %d items.", len(received))
		}
	}
}

func Test{{sel "Name"}}Mutate(t *testing.T) {
	t.Logf("When data is mutated but not received due to context expiration on receive")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 5*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		defer close(incoming)

		outgoing := services.{{sel "Name"}}Mutate(ctx, 2*time.Millisecond, func(item {{sel "Type"}}) {{sel "Type"}} { return item }, incoming)

		_, ok := <-outgoing
		if ok {
			tests.Failed("Should have recieved close signal due to context expiration")
		}
		tests.Passed("Should have recieved close signal due to context expiration")
	}

	t.Logf("When data is mutated on each receive")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 10*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		outgoing := services.{{sel "Name"}}Mutate(ctx, 10*time.Millisecond, func(item {{sel "Type"}}) {{sel "Type"}} {
			return item
		}, incoming)

		go func() {
			defer close(incoming)

			for i :=1; i > 0; i-- {
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming <- {{sel "Type"}}("bashful")
				{{ end }}

				{{ if  eq (sel "Type") "uint" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming <- fmt.Sprintf("%q","monday")
				{{ end }}
			}
		}()

		_, ok := <-outgoing
		if !ok {
			tests.Failed("Should have recieved item as value but got %t", ok)
		}
		tests.Passed("Should have recieved false as value")

		_, ok = <-outgoing
		if ok {
			tests.Failed("Should have recieved close signal")
		}
		tests.Passed("Should have recieved close signal")
	}
}

func Test{{sel "Name"}}View(t *testing.T) {
	t.Logf("When data is View but not received due to context expiration on receive")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 5*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		defer close(incoming)

		outgoing := services.{{sel "Name"}}View(ctx, 2*time.Millisecond, func(item {{sel "Type"}}) {}, incoming)

		_, ok := <-outgoing
		if ok {
			tests.Failed("Should have recieved close signal due to context expiration")
		}
		tests.Passed("Should have recieved close signal due to context expiration")
	}

	t.Logf("When data is filtered on each receive")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 10*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		inview := make(chan {{sel "Type"}}, 0)

		outgoing := services.{{sel "Name"}}View(ctx, 10*time.Millisecond, func(item {{sel "Type"}})  {
			inview <- item
		}, incoming)

		go func() {
			defer close(incoming)

			for i := 1; i > 0; i-- {
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming <- {{sel "Type"}}("bashful")
				{{ end }}

				{{ if  eq (sel "Type") "uint" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming <- fmt.Sprintf("%q","monday")
				{{ end }}
			}
		}()


		_, ok := <-outgoing
		if !ok {
			tests.Failed("Should have recieved only 1 item as value but got %t", ok)
		}
		tests.Passed("Should have recieved 1 item")

		_, ok = <-inview
		if !ok {
			tests.Failed("Should have recieved only 1 item as value but got %t", ok)
		}
		tests.Passed("Should have recieved 1 item")

		_, ok = <-outgoing
		if ok {
			tests.Failed("Should have recieved close signal")
		}
		tests.Passed("Should have recieved 1 item")
	}
}



func Test{{sel "Name"}}Filter(t *testing.T) {
	t.Logf("When data is filtered but not received due to context expiration on receive")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 5*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		defer close(incoming)

		outgoing := services.{{sel "Name"}}Filter(ctx, 2*time.Millisecond, func(item {{sel "Type"}}) bool {
			return true
		}, incoming)
		_, ok := <-outgoing
		if ok {
			tests.Failed("Should have recieved close signal due to context expiration")
		}
		tests.Passed("Should have recieved close signal due to context expiration")
	}

	t.Logf("When data is filtered on each receive")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 10*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		outgoing := services.{{sel "Name"}}Filter(ctx, 10*time.Millisecond, func(item {{sel "Type"}}) bool {
			return true
		}, incoming)

		go func() {
			defer close(incoming)

			for i := 1; i > 0; i-- {
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming <- {{sel "Type"}}("bashful")
				{{ end }}

				{{ if  eq (sel "Type") "uint" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming <- fmt.Sprintf("%q","monday")
				{{ end }}
			}
		}()

		_, ok := <-outgoing
		if !ok {
			tests.Failed("Should have recieved only 1 item as value but got %t", ok)
		}
		tests.Passed("Should have recieved false as value")

		_, ok = <-outgoing
		if ok {
			tests.Failed("Should have recieved close signal")
		}
		tests.Passed("Should have recieved close signal")
	}
}

func Test{{sel "Name"}}CollectUntil(t *testing.T) {
	t.Logf("When data is collected until condition is met except when context expiration on receive")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 5*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		defer close(incoming)

		outgoing := services.{{sel "Name"}}CollectUntil(ctx, 2*time.Millisecond, func(item []{{sel "Type"}}) bool { return true }, incoming)

		_, ok := <-outgoing
		if ok {
			tests.Failed("Should have recieved close signal due to context expiration")
		}
		tests.Passed("Should have recieved close signal due to context expiration")
	}

	t.Logf("When data is collected until condition is met")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 10*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		outgoing := services.{{sel "Name"}}CollectUntil(ctx, 10*time.Millisecond, func(items []{{sel "Type"}}) bool {
			return len(items) == 2
		}, incoming)

		go func() {
			defer close(incoming)

			for i := 3; i > 0; i-- {
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming <- {{sel "Type"}}("bashful")
				{{ end }}

				{{ if  eq (sel "Type") "uint" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming <- 2 * 2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming <- fmt.Sprintf("%q","monday")
				{{ end }}
			}
		}()

		received1 := <-outgoing
		if len(received1) != 2 {
			tests.Failed("Should have recieved 2 item slice but got %d item slice", len(received1))
		}
		tests.Passed("Should have recieved 2 item slice")

		received2 := <-outgoing
		if len(received2) != 1 {
			tests.Failed("Should have recieved 1 item slice but got %d item slice", len(received2))
		}
		tests.Passed("Should have recieved 1 item slice")

		_, ok := <-outgoing
		if ok {
			tests.Failed("Should have recieved close signal")
		}
		tests.Passed("Should have recieved close signal")
	}
}

func Test{{sel "Name"}}MergeWithoutOrder(t *testing.T) {
	t.Logf("When data is merged from multiple channels in incoming order but context expires so nothing is received")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 5*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		defer close(incoming)

		outgoing := services.{{sel "Name"}}MergeWithoutOrder(ctx, 2*time.Millisecond, incoming)

		_, ok := <-outgoing
		if ok {
			tests.Failed("Should have recieved close signal due to context expiration")
		}
		tests.Passed("Should have recieved close signal due to context expiration")
	}

	t.Logf("When data is merged from multiple channels in data incoming order")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 10*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		defer close(incoming)

		incoming2 := make(chan {{sel "Type"}}, 0)
		defer close(incoming2)

		incoming3 := make(chan {{sel "Type"}}, 0)
		defer close(incoming3)

		outgoing := services.{{sel "Name"}}MergeWithoutOrder(ctx, 10*time.Millisecond, incoming, incoming2, incoming3)

	
		go func() {
			time.Sleep(3 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming <- {{sel "Type"}}("bashful")
				{{ end }}

				{{ if  eq (sel "Type") "uint" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		go func() {
			time.Sleep(1 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming2 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming2 <- {{sel "Type"}}('b')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming2 <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming2 <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming2 <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming2 <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		go func() {
			time.Sleep(2 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming3 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming3 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming3 <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming3 <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming3 <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming3 <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		received := <-outgoing
		if received == nil {
			tests.Failed("Should have recieved 9 item slice but got %d item slice", len(received))
		}
		tests.Passed("Should have recieved 9 item slice")
	}
}

func Test{{sel "Name"}}MergeInOrder(t *testing.T) {
	t.Logf("When data is merged from multiple channels in provided order but context expires so nothing is received")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 5*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		defer close(incoming)

		outgoing := services.{{sel "Name"}}MergeInOrder(ctx, 2*time.Millisecond, incoming)

		_, ok := <-outgoing
		if ok {
			tests.Failed("Should have recieved close signal due to context expiration")
		}
		tests.Passed("Should have recieved close signal due to context expiration")
	}

	t.Logf("When data is merged from multiple channels in provided channel order")
	{
		ctx, cancl := context.WithTimeout(context.Background(), 10*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		defer close(incoming)

		incoming2 := make(chan {{sel "Type"}}, 0)
		defer close(incoming2)

		incoming3 := make(chan {{sel "Type"}}, 0)
		defer close(incoming3)

		outgoing := services.{{sel "Name"}}MergeInOrder(ctx, 1*time.Millisecond, incoming, incoming2, incoming3)

	
		go func() {
			time.Sleep(3 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		go func() {
			time.Sleep(1 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming2 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming2 <- {{sel "Type"}}('b')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming2 <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming2 <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming2 <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming2 <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		go func() {
			time.Sleep(2 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming3 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming3 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming3 <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming3 <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming3 <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming3 <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		received := <-outgoing
		if received == nil {
			tests.Failed("Should have recieved 9 item slice but got %d item slice", len(received))
		}
		tests.Passed("Should have recieved 9 item slice")
	}
}

func Test{{sel "Name"}}CombinePartiallyWithoutOrder(t *testing.T) {
	t.Logf("When data is combined from multiple channels without provided order but context expires so nothing is received")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 5*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		defer close(incoming)

		outgoing := services.{{sel "Name"}}CombinePartiallyWithoutOrder(ctx, 2*time.Millisecond, incoming)

		_, ok := <-outgoing
		if ok {
			tests.Failed("Should have recieved close signal due to context expiration")
		}
		tests.Passed("Should have recieved close signal due to context expiration")
	}

	t.Logf("When data is combined from multiple channels without channel order")
	{
		ctx, cancl := context.WithTimeout(context.Background(), 10*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		defer close(incoming)

		incoming2 := make(chan {{sel "Type"}}, 0)
		defer close(incoming2)

		incoming3 := make(chan {{sel "Type"}}, 0)
		defer close(incoming3)

		outgoing := services.{{sel "Name"}}CombinePartiallyWithoutOrder(ctx, 1*time.Millisecond, incoming, incoming2, incoming3)

	
		go func() {
			time.Sleep(3 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming <- {{sel "Type"}}("bashful")
				{{ end }}

				{{ if  eq (sel "Type") "uint" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		go func() {
			time.Sleep(1 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming2 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming2 <- {{sel "Type"}}('b')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming2 <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming2 <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming2 <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming2 <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		go func() {
			time.Sleep(2 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming3 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming3 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming3 <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming3 <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming3 <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming3 <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		received := <-outgoing
		if received == nil {
			tests.Failed("Should have recieved 3 item slice but got %d item slice", len(received))
		}
		tests.Passed("Should have recieved 3 item slice")

	}
}

func Test{{sel "Name"}}CombineWithoutOrder(t *testing.T) {
	t.Logf("When data is combined from multiple channels in incoming order but context expires so nothing is received")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 5*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		defer close(incoming)

		outgoing := services.{{sel "Name"}}CombineWithoutOrder(ctx, 2*time.Millisecond, incoming)

		_, ok := <-outgoing
		if ok {
			tests.Failed("Should have recieved close signal due to context expiration")
		}
		tests.Passed("Should have recieved close signal due to context expiration")
	}

	t.Logf("When data is merged from multiple channels in data incoming order")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 10*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)

		incoming2 := make(chan {{sel "Type"}}, 0)

		incoming3 := make(chan {{sel "Type"}}, 0)

		outgoing := services.{{sel "Name"}}CombineWithoutOrder(ctx, 10*time.Millisecond, incoming, incoming2, incoming3)

	
		go func() {
			defer close(incoming)
			time.Sleep(3 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming <- {{sel "Type"}}('b')
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		go func() {
			defer close(incoming2)
			time.Sleep(1 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming2 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming2 <- {{sel "Type"}}('b')
				{{ end }}
				{{ if  eq (sel "Type") "rune" }}
				 incoming2 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming2 <- {{sel "Type"}}('b')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming2 <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming2 <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming2 <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming2 <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		go func() {
			defer close(incoming3)
			time.Sleep(2 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if  eq (sel "Type") "rune" }}
				 incoming3 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming3 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming3 <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming3 <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming3 <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming3 <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		received := <-outgoing
		if received == nil {
			tests.Failed("Should have recieved 3 item slice but got %d item slice", len(received))
		}
		tests.Passed("Should have recieved 3 item slice")

	}
}

func Test{{sel "Name"}}CombineInOrder(t *testing.T) {
	t.Logf("When data is merged from multiple channels in provided order but context expires so nothing is received")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 5*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		defer close(incoming)

		outgoing := services.{{sel "Name"}}CombineInOrder(ctx, 2*time.Millisecond, incoming)

		_, ok := <-outgoing
		if ok {
			tests.Failed("Should have recieved close signal due to context expiration")
		}
		tests.Passed("Should have recieved close signal due to context expiration")
	}

	t.Logf("When data is merged from multiple channels in provided channel order")
	{
		ctx, cancl := context.WithTimeout(context.Background(), 10*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		defer close(incoming)

		incoming2 := make(chan {{sel "Type"}}, 0)
		defer close(incoming2)

		incoming3 := make(chan {{sel "Type"}}, 0)
		defer close(incoming3)

		outgoing := services.{{sel "Name"}}CombineInOrder(ctx, 2*time.Millisecond, incoming, incoming2, incoming3)

		
		go func() {
			time.Sleep(3 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		go func() {
			time.Sleep(1 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming2 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming2 <- {{sel "Type"}}('b')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming2 <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming2 <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming2 <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming2 <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		go func() {
			time.Sleep(2 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
 
				{{ if  eq (sel "Type") "rune" }}
				 incoming3 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming3 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming3 <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming3 <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming3 <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming3 <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		received := <-outgoing
		if received == nil {
			tests.Failed("Should have recieved 3 item slice but got %d item slice", len(received))
		}
		tests.Passed("Should have recieved 3 item slice")
	}
}

func Test{{sel "Name"}}CombineInPartialOrder(t *testing.T) {
	t.Logf("When data is combined from multiple channels in provided order but context expires so nothing is received")
	{

		ctx, cancl := context.WithTimeout(context.Background(), 5*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)
		defer close(incoming)

		outgoing := services.{{sel "Name"}}CombineInPartialOrder(ctx, 2*time.Millisecond, incoming)

		_, ok := <-outgoing
		if ok {
			tests.Failed("Should have recieved close signal due to context expiration")
		}
		tests.Passed("Should have recieved close signal due to context expiration")
	}

	t.Logf("When data is combined from multiple channels in provided channel order")
	{
		ctx, cancl := context.WithTimeout(context.Background(), 10*time.Millisecond)
		defer cancl()

		incoming := make(chan {{sel "Type"}}, 0)

		incoming2 := make(chan {{sel "Type"}}, 0)
		defer close(incoming2)

		incoming3 := make(chan {{sel "Type"}}, 0)
		defer close(incoming3)

		outgoing := services.{{sel "Name"}}CombineInPartialOrder(ctx, 2*time.Millisecond, incoming, incoming2, incoming3)

	
		go func() {
			defer close(incoming)

			time.Sleep(3 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if  eq (sel "Type") "rune" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "rune" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		go func() {
			time.Sleep(1 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming2 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if  eq (sel "Type") "rune" }}
				 incoming2 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming2 <- {{sel "Type"}}('b')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming2 <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming2 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming2 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming2 <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming2 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming2 <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming2 <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		go func() {
			time.Sleep(2 * time.Millisecond)
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 incoming3 <- {{sel "Type"}}{"day":"monday"}
				{{ end }}
				{{ if  eq (sel "Type") "rune" }}
				 incoming3 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 incoming3 <- {{sel "Type"}}('l')
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 incoming3 <- {{sel "Type"}}("bashful")
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				 incoming3 <- 1
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				 incoming3 <- 2.0
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				 incoming3 <- 2%2 == 0
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				 incoming3 <-  2
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				 incoming3 <- errors.New(fmt.Sprintf("%q","monday"))
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				 incoming3 <- fmt.Sprintf("%q","monday")
				{{ end }}
		}()

		received := <-outgoing
		if received == nil {
			tests.Failed("Should have recieved 3 item slice but got %d item slice", len(received))
		}
		tests.Passed("Should have recieved 3 item slice")

	}
}

func Test{{sel "Name"}}Distributor(t *testing.T) {
	dist := services.New{{sel "Name"}}Distributor(0, 1*time.Second)

	incoming := make(chan {{sel "Type"}}, 1)
	incoming2 := make(chan {{sel "Type"}}, 1)
	incoming3 := make(chan {{sel "Type"}}, 1)

	dist.Subscribe(incoming)
	dist.Subscribe(incoming2)
	dist.Subscribe(incoming3)

	defer dist.Stop()
	
	dist.Publish(
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				{{sel "Type"}}{"day":"monday"},
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 {{sel "Type"}}{"day":"monday"},
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 {{sel "Type"}}{"day":"monday"},
				{{ end }}
				{{ if  eq (sel "Type") "rune" }}
				 {{sel "Type"}}('l'),
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 {{sel "Type"}}('l'),
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 {{sel "Type"}}("bashful"),
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				  1,
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				   2,
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				  1,
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				  1,
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				   2,
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				   2,
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				   2,
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				   2,
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				   2,
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				  2.0,
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				  2.0,
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				  2.0,
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				  2.0,
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				  6%2 == 0,
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				   2,
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				  errors.New(fmt.Sprintf("%q","monday")),
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				  fmt.Sprintf("%q","monday"),
				{{ end }}
	)

	select {
	case <-time.After(15 * time.Millisecond):
		tests.Failed("Should have received a published item before expiration")
	case initial := <-incoming:
		tests.Passed("Should have received a matching data on first channel")

		if !is{{sel "Name"}}Equal(initial, <-incoming2) {
			tests.Failed("Should have received a matching data on second channel")
		}
		tests.Passed("Should have received a matching data on second channel")

		if !is{{sel "Name"}}Equal(initial, <-incoming3) {
			tests.Failed("Should have received a matching data on third channel")
		}
		tests.Passed("Should have received a matching data on third channel")
	}

	dist.Stop()

	dist.PublishDeadline(
				{{ if eq (sel "Type") "map[interface{}]interface{}" }}
				{{sel "Type"}}{"day":"monday"},
				{{ end }}
				{{ if eq (sel "Type") "map[string]interface{}" }}
				 {{sel "Type"}}{"day":"monday"},
				{{ end }}
				{{ if eq (sel "Type") "map[string]string" }}
				 {{sel "Type"}}{"day":"monday"},
				{{ end }}
				{{ if  eq (sel "Type") "rune" }}
				 {{sel "Type"}}('l'),
				{{ end }}
				{{ if  eq (sel "Type") "byte" }}
				 {{sel "Type"}}('l'),
				{{ end }}
				{{ if  eq (sel "Type") "[]byte" }}
				 {{sel "Type"}}("bashful"),
				{{ end }}
				{{ if  eq (sel "Type") "uint" }}
				  1,
				{{ end }}
				{{ if  eq (sel "Type") "uint8" }}
				   2,
				{{ end }}
				{{ if  eq (sel "Type") "uint32" }}
				  1,
				{{ end }}
				{{ if  eq (sel "Type") "uint64" }}
				  1,
				{{ end }}
				{{ if  eq (sel "Type") "int64" }}
				   2,
				{{ end }}
				{{ if  eq (sel "Type") "int32" }}
				   2,
				{{ end }}
				{{ if  eq (sel "Type") "int16" }}
				   2,
				{{ end }}
				{{ if  eq (sel "Type") "int8" }}
				   2,
				{{ end }}
				{{ if  eq (sel "Type") "int" }}
				   2,
				{{ end }}
				{{ if  eq (sel "Type") "complex128" }}
				  2.0,
				{{ end }}
				{{ if  eq (sel "Type") "complex64" }}
				  2.0,
				{{ end }}
				{{ if  eq (sel "Type") "float64" }}
				  2.0,
				{{ end }}
				{{ if  eq (sel "Type") "float32" }}
				  2.0,
				{{ end }}
				{{ if  eq (sel "Type") "bool" }}
				  6%2 == 0,
				{{ end }}
				{{ if  eq (sel "Type") "interface{}" }}
				   2,
				{{ end }}
				{{ if  eq (sel "Type") "error" }}
				  errors.New(fmt.Sprintf("%q","monday")),
				{{ end }}
				{{ if  eq (sel "Type") "string" }}
				  fmt.Sprintf("%q","monday"),
				{{ end }}
				1*time.Millisecond,
			)

	if len(incoming) != 0 || len(incoming2) != 0 || len(incoming3) != 0 {
		tests.Failed("Should not have received any items after publisher is stopped")
	}
	tests.Passed("Should not have received any items after publisher is stopped")
}

func is{{sel "Name"}}Equal(item1, item2 {{sel "Type"}}) bool {
	{{ if hasPrefix (sel "Type") "map" }}
		if item2 == nil {
			return false
		}

		if item1 == nil {
			return false
		}

		for index, item := range item1 {
			if item2[index] != item {
				return false
			}
		}
	{{else}}
		{{if hasPrefix (sel "Type") "[]"}}
			if len(item1) != len(item2) {
				return false
			}

			for index, item := range item1 {
				if item2[index] != item {
					return false
				}
			}
		{{else}}
			if item1 != item2 {
				return false
			}
		{{end}}
	{{end}}

	return true
}

{{if hasPrefix (sel "Type") "[]"}}
{{else}}
func is{{sel "Name"}}EqualSlice(item1 []{{sel "Type"}}, item2 []{{sel "Type"}}) bool {
	if len(item1) != len(item2) {
		return false
	}

	for index, item := range item1 {
		if !is{{sel "Name"}}Equal(item, item2[index]) {
			return false
		}
	}

	return true
}
{{end}}
